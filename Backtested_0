Backtested 2025-10-01 00:00:00 -> 2025-11-01 00:00:00 | Max open trades : 1
                                         STRATEGY SUMMARY                                          
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ            ‚îÉ        ‚îÉ Avg Profit ‚îÉ Tot Profit ‚îÉ Tot Profit ‚îÉ       Avg ‚îÉ  Win  Draw ‚îÉ           ‚îÉ
‚îÉ   Strategy ‚îÉ Trades ‚îÉ          % ‚îÉ       USDC ‚îÉ          % ‚îÉ  Duration ‚îÉ Loss  Win% ‚îÉ  Drawdown ‚îÉ
‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î©
‚îÇ WaveHyper‚Ä¶ ‚îÇ     26 ‚îÇ       0.14 ‚îÇ     35.764 ‚îÇ       3.58 ‚îÇ   2:05:00 ‚îÇ   11    15 ‚îÇ    0 USDC ‚îÇ
‚îÇ            ‚îÇ        ‚îÇ            ‚îÇ            ‚îÇ            ‚îÇ           ‚îÇ    0   100 ‚îÇ     0.00% ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


import numpy as np
import pandas as pd
from pandas import DataFrame
from functools import reduce
import talib.abstract as ta
from freqtrade.strategy import IStrategy, DecimalParameter, IntParameter, CategoricalParameter, Trade
from datetime import datetime
from typing import Optional
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class WaveHyperNWStrategycopy(IStrategy):
    INTERFACE_VERSION = 3

    timeframe = '5m'
    stoploss = -0.09
    minimal_roi = {
        "0": 0.008,
        "3": 0.006,
        "8": 0.004,
        "15": 0.002,
        "30": 0.0
    }

    trailing_stop = True
    trailing_stop_positive = 0.046
    trailing_stop_positive_offset = 0.058
    trailing_only_offset_is_reached = True

    # Par√¢metros otimizados - mais permissivos
    wt_channel_len = IntParameter(3, 10, default=5, space='buy')
    wt_average_len = IntParameter(10, 20, default=12, space='buy')
    wt_overbought2 = DecimalParameter(45, 60, default=50, space='sell')
    wt_oversold2 = DecimalParameter(-60, -45, default=-50, space='buy')

    cooldown_lookback = IntParameter(2, 48, default=5, space="protection", optimize=True)
    stop_duration = IntParameter(12, 200, default=5, space="protection", optimize=True)
    use_stop_protection = CategoricalParameter([True, False], default=True, space="protection", optimize=True)

    # Configura√ß√µes adicionais
    startup_candle_count: int = 100
    can_short = False

    def __init__(self, config: dict) -> None:
        super().__init__(config)
        self.logger = logging.getLogger(__name__)
        self.last_entry_signal_state = {}  # Dicion√°rio para rastrear o √∫ltimo estado de enter_long por par

        # protections como atributo de inst√¢ncia
        if self.use_stop_protection.value:
            self.protections = [
                {
                    "method": "CooldownPeriod",
                    "stop_duration_candles": int(self.stop_duration.value)
                },
                {
                    "method": "StoplossGuard",
                    "lookback_period_candles": int(self.cooldown_lookback.value),
                    "trade_limit": 4,
                    "stop_duration_candles": int(self.stop_duration.value),
                    "only_per_pair": False
                }
            ]
        else:
            self.protections = []

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # Verificar se h√° dados suficientes
        if len(dataframe) < 50:
            logger.warning(f"Dados insuficientes para {metadata.get('pair', 'unknown')}: {len(dataframe)} velas")
            return dataframe

        # Remover √≠ndices duplicados para evitar erro de reindex
        dataframe = dataframe[~dataframe.index.duplicated(keep='last')]

        # WaveTrend
        ap = (dataframe['high'] + dataframe['low'] + dataframe['close']) / 3
        wt_channel_len = int(self.wt_channel_len.value)
        wt_average_len = int(self.wt_average_len.value)

        esa = ta.EMA(ap, timeperiod=wt_channel_len)  # type: ignore[attr-defined]
        d = ta.EMA(abs(ap - esa), timeperiod=wt_channel_len)  # type: ignore[attr-defined]
        ci = (ap - esa) / (0.015 * d + 1e-10)  # Evitar divis√£o por zero
        tci = ta.EMA(ci, timeperiod=wt_average_len)  # type: ignore[attr-defined]

        dataframe['wt1'] = tci
        dataframe['wt2'] = ta.SMA(dataframe['wt1'], timeperiod=4)  # type: ignore[attr-defined]

        # Cruzamentos WaveTrend
        dataframe['wt_cross_up'] = (
            (dataframe['wt1'] > dataframe['wt2']) &
            (dataframe['wt1'].shift(1) <= dataframe['wt2'].shift(1))
        )
        dataframe['wt_cross_down'] = (
            (dataframe['wt1'] < dataframe['wt2']) &
            (dataframe['wt1'].shift(1) >= dataframe['wt2'].shift(1))
        )

        # Indicadores adicionais
        dataframe['rsi'] = ta.RSI(dataframe['close'], timeperiod=14)  # type: ignore[attr-defined]
        dataframe['atr'] = ta.ATR(dataframe['high'], dataframe['low'], dataframe['close'], timeperiod=14)  # type: ignore[attr-defined]

        # M√©dias m√≥veis
        dataframe['ema_8'] = ta.EMA(dataframe['close'], timeperiod=8)  # type: ignore[attr-defined]
        dataframe['ema_21'] = ta.EMA(dataframe['close'], timeperiod=21)  # type: ignore[attr-defined]
        dataframe['ema_50'] = ta.EMA(dataframe['close'], timeperiod=50)  # type: ignore[attr-defined]

        # Volume e volatilidade
        dataframe['volume_mean'] = dataframe['volume'].rolling(window=24).mean()
        dataframe['volatility_pct'] = dataframe['atr'] / dataframe['close'] * 100  # ATR em %

        # Nadaraya-Watson
        close = dataframe['close'].to_numpy()
        # Simple kernel para evitar erros
        weights = np.ones(41) / 41
        nw = np.convolve(close, weights, mode='same')

        dataframe['nw_upper'] = pd.Series(nw) + 0.8 * dataframe['close'].rolling(10).std()
        dataframe['nw_lower'] = pd.Series(nw) - 0.8 * dataframe['close'].rolling(10).std()

        # Tend√™ncia
        dataframe['trend_up'] = (
            (dataframe['ema_8'] > dataframe['ema_21']) &
            (dataframe['ema_21'] > dataframe['ema_50'])
        )

        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # Remover √≠ndices duplicados para evitar erro de reindex
        dataframe = dataframe[~dataframe.index.duplicated(keep='last')]

        # Inicializar coluna
        dataframe.loc[:, 'enter_long'] = 0
        dataframe.loc[:, 'enter_tag'] = ''

        # Condi√ß√µes principais de entrada - mais seletivas
        entry_conditions = (
            # WaveTrend: APENAS cruzamentos fortes
            (
                dataframe['wt_cross_up'] &
                (dataframe['wt1'] < self.wt_oversold2.value) &
                (dataframe['wt1'] > dataframe['wt1'].shift(1))  # Momentum crescente
            ) &

            # Volume significativo (aumentado)
            (dataframe['volume'] > dataframe['volume_mean'] * 0.8) &

            # RSI em zona ideal
            (dataframe['rsi'] < 35) &

            # Confirma√ß√£o de tend√™ncia OU oversold extremo
            (
                (
                    dataframe['trend_up'] &
                    (dataframe['close'] > dataframe['ema_8'] * 0.999)  # Pre√ßo pr√≥ximo da EMA8
                ) |
                (
                    (dataframe['close'] < dataframe['nw_lower']) &
                    (dataframe['rsi'] < 30) &  # RSI muito baixo
                    (dataframe['wt1'] < -55)   # WT muito oversold
                )
            ) &

            # Filtro adicional: evitar entrada em quedas livres
            (dataframe['close'] > dataframe['close'].shift(3) * 0.98) &  # N√£o caiu >2% em 3 velas

            # Filtro de volatilidade (evitar mercados muito agitados)
            (dataframe['volatility_pct'] < 3.0)
        )

        # Marcar sinais de entrada
        dataframe.loc[entry_conditions, 'enter_long'] = 1

        # Adicionar tag informativa
        dataframe.loc[
            entry_conditions,
            'enter_tag'
        ] = (
            'WT:' + dataframe['wt1'].round(1).astype(str) + '/' +
            dataframe['wt2'].round(1).astype(str) +
            ' RSI:' + dataframe['rsi'].round(0).astype(str)
        )

        # Log para debug
        if entry_conditions.any():
            entries = dataframe[entry_conditions]
            logger.info(f"Sinais de entrada para {metadata['pair']}: {len(entries)} velas")

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[:, 'exit_long'] = 0
        dataframe.loc[:, 'exit_tag'] = ''

        # Condi√ß√µes de sa√≠da - mais permissivas
        exit_conditions = (
            # WaveTrend cruzamento para baixo em zona de sobrecompra
            (
                (dataframe['wt_cross_down'] | (dataframe['wt1'] < dataframe['wt2'])) &
                (dataframe['wt1'] > self.wt_overbought2.value)
            ) &

            # Volume m√≠nimo
            (dataframe['volume'] > dataframe['volume_mean'] * 0.3) &

            # Condi√ß√µes de profit ou revers√£o - simplificadas
            (
                # Profit target (reduzido)
                (dataframe['close'] > dataframe['ema_8'] * 1.015) |

                # Revers√£o
                (
                    (dataframe['close'] < dataframe['ema_8']) &
                    (dataframe['rsi'] > 65)
                )
            )
        )

        dataframe.loc[exit_conditions, 'exit_long'] = 1
        dataframe.loc[
            exit_conditions,
            'exit_tag'
        ] = 'WT_exit RSI:' + dataframe['rsi'].round(0).astype(str)

        return dataframe

    def bot_loop_start(self, current_time: datetime, **kwargs) -> None:
        for pair in self.dp.current_whitelist():
            dataframe, last_analyzed = self.dp.get_analyzed_dataframe(pair, self.timeframe)
            if dataframe is not None and not dataframe.empty:
                current_time = dataframe['date'].iloc[-1]
                if pair not in self.last_entry_signal_state:
                    self.last_entry_signal_state[pair] = 0
                current_state = dataframe['enter_long'].iloc[-1]
                previous_state = self.last_entry_signal_state[pair]

                if current_state == 1 and previous_state == 0:
                    logger.info(f"Novo sinal de entrada detectado para {pair} √†s {current_time}")
                    message = (
                        f"üìà Sinal de entrada detectado para {pair}!\n"
                        f"Data: {current_time}\n"
                        f"Pre√ßo: {dataframe['close'].iloc[-1]:.2f}\n"
                        f"WT1: {dataframe['wt1'].iloc[-1]:.2f}, WT2: {dataframe['wt2'].iloc[-1]:.2f}\n"
                        f"EMA8: {dataframe['ema_8'].iloc[-1]:.2f}, EMA21: {dataframe['ema_21'].iloc[-1]:.2f}\n"
                        f"EMA50: {dataframe['ema_50'].iloc[-1]:.2f}\n"
                        f"Volume: {dataframe['volume'].iloc[-1]:.2f}\n"
                        f"RSI: {dataframe['rsi'].iloc[-1]:.2f}"
                    )
                    try:
                        self.dp.send_msg(message)
                        logger.info(f"Mensagem enviada ao Telegram: {message}")
                    except Exception as e:
                        logger.error(f"Falha ao enviar mensagem ao Telegram: {e}")
                else:
                    logger.debug(f"Nenhum novo sinal de entrada para {pair} √†s {current_time}")

                self.last_entry_signal_state[pair] = current_state

    def custom_stoploss(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        after_fill: bool,
        **kwargs
    ) -> Optional[float]:
        # Stop loss mais agressivo para capturar lucros rapidamente

        # Realizar lucros mais rapidamente
        if current_profit > 0.015:    # 1.5%
            return 0.008              # Move para +0.8%
        elif current_profit > 0.01:   # 1%
            return 0.005              # Move para +0.5%
        elif current_profit > 0.008:  # 0.8%
            return 0.002              # Move para +0.2%
        elif current_profit > 0.005:  # 0.5%
            return -0.002             # Move para -0.2%

        # Stop loss por tempo - mais agressivo
        trade_duration = (current_time - trade.open_date_utc).total_seconds()

        if trade_duration < 600:       # Primeiros 10 min
            return -0.003              # -0.3%
        elif trade_duration < 1200:    # Primeiros 20 min
            return -0.005              # -0.5%
        elif trade_duration < 2400:    # Primeiros 40 min
            return -0.008              # -0.8%
        else:
            return -0.012              # M√°ximo -1.2%

{
  "$schema": "https://schema.freqtrade.io/schema.json",
  "max_open_trades": 1,
  "stake_currency": "USDC",
  "stake_amount": "unlimited",
  "tradable_balance_ratio": 0.95,
  "fiat_display_currency": "USD",
  "amount_reserve_percent": 0.05,
  "available_capital": 1000,
  "amend_last_stake_amount": false,
  "last_stake_amount_min_ratio": 0.5,
  "dry_run": true,
  "dry_run_wallet": 1000,
  "cancel_open_orders_on_exit": false,
  "timeframe": "5m",
  "trailing_stop": false,
  "trailing_stop_positive": 0.0,
  "trailing_stop_positive_offset": 0.0,
  "trailing_only_offset_is_reached": true,
  "use_exit_signal": true,
  "exit_profit_only": false,
  "exit_profit_offset": 0.0,
  "ignore_roi_if_entry_signal": false,
  "ignore_buying_expired_candle_after": 300,
  "trading_mode": "spot",
  "margin_mode": "",
  "stoploss": -0.06,
  "unfilledtimeout": {
    "entry": 10,
    "exit": 10,
    "exit_timeout_count": 0,
    "unit": "minutes"
  },
  "entry_pricing": {
    "price_side": "same",
    "use_order_book": true,
    "order_book_top": 1,
    "price_last_balance": 0.0,
    "check_depth_of_market": {
      "enabled": false,
      "bids_to_ask_delta": 1
    }
  },
  "exit_pricing": {
    "price_side": "same",
    "use_order_book": true,
    "order_book_top": 1,
    "price_last_balance": 0.0
  },
  "order_types": {
    "entry": "limit",
    "exit": "limit",
    "emergency_exit": "market",
    "force_exit": "market",
    "force_entry": "market",
    "stoploss": "market",
    "stoploss_on_exchange": false,
    "stoploss_price_type": "last",
    "stoploss_on_exchange_interval": 60,
    "stoploss_on_exchange_limit_ratio": 0.99
  },
  "order_time_in_force": {
    "entry": "GTC",
    "exit": "GTC"
  },
  "pairlists": [
    {
      "method": "StaticPairList"
    }
  ],
  "exchange": {
    "name": "binance",
    "key": "your_exchange_key",
    "secret": "your_exchange_secret",
    "password": "",
    "log_responses": false,
    "ccxt_config": {},
    "ccxt_async_config": {},
    "pair_whitelist": [
      "ETH/USDC",
      "BNB/USDC",
      "ADA/USDC",
      "SOL/USDC",
      "DOT/USDC",
      "DOGE/USDC",
      "AVAX/USDC",
      "LTC/USDC"
    ],
    "pair_blacklist": [],
    "outdated_offset": 5,
    "markets_refresh_interval": 60
  },
  "telegram": {
    "enabled": false,
    "token": "your_telegram_token",
    "chat_id": "your_telegram_chat_id",
    "notification_settings": {
      "status": "on",
      "warning": "on",
      "startup": "on",
      "entry": "on",
      "entry_fill": "on",
      "exit": {
        "roi": "off",
        "emergency_exit": "off",
        "force_exit": "off",
        "exit_signal": "off",
        "trailing_stop_loss": "off",
        "stop_loss": "off",
        "stoploss_on_exchange": "off",
        "custom_exit": "off"
      },
      "exit_fill": "on",
      "entry_cancel": "on",
      "exit_cancel": "on",
      "protection_trigger": "off",
      "protection_trigger_global": "on",
      "show_candle": "off"
    },
    "reload": true,
    "balance_dust_level": 0.01
  },
  "api_server": {
    "enabled": true,
    "listen_ip_address": "127.0.0.1",
    "listen_port": 8080,
    "verbosity": "error",
    "enable_openapi": false,
    "jwt_secret_key": "somethingrandom",
    "CORS_origins": [],
    "username": "freqtrader",
    "password": "SuperSecurePassword",
    "ws_token": "secret_ws_t0ken."
  },
  "external_message_consumer": {
    "enabled": false,
    "producers": [
      {
        "name": "default",
        "host": "127.0.0.2",
        "port": 8080,
        "ws_token": "secret_ws_t0ken."
      }
    ],
    "wait_timeout": 300,
    "ping_timeout": 10,
    "sleep_time": 10,
    "remove_entry_exit_signals": false,
    "message_size_limit": 8
  },
  "bot_name": "freqtrade",
  "db_url": "sqlite:///tradesv3.sqlite",
  "initial_state": "running",
  "force_entry_enable": false,
  "internals": {
    "process_throttle_secs": 5,
    "heartbeat_interval": 60
  },
  "disable_dataframe_checks": false,
  "strategy": "WaveHyperNWStrategycopy",
  "strategy_path": "user_data/strategies/",
  "recursive_strategy_search": false,
  "add_config_files": [],
  "reduce_df_footprint": false,
  "dataformat_ohlcv": "feather",
  "dataformat_trades": "feather"
}



